package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.util.BlockPos

@ModuleInfo(name = "TeleportExploit", spacedName = "Teleport Exploit", description = "Teleport by exploiting a bug with certain anticheats after you respawn/get teleported.", category = ModuleCategory.EXPLOIT)
class TeleportExploit : Module() {

    private val delay = IntegerValue("Delay", 5, 1, 30, "s")
    private val timer = TickTimer()
    private var stage = 0
    private var tpPos: BlockPos = mc.thePlayer.position

    override fun onEnable() {
        reset()
    }

    override fun onDisable() {
        reset()
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        reset()
        this.toggle()
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        if (mc.thePlayer == null || mc.theWorld == null) { this.toggle(); return }

        if (timer.hasTimePassed(20*delay.get())) {
            tpPos = mc.thePlayer.position
            stage = 1
        } else {
            if (mc.thePlayer.ticksExisted % 20 == 0)
                ClientUtils.displayChatMessage("You are in desync! You have ${20*delay.get() - timer.tick/20} seconds left to choose your position")

            mc.thePlayer.noClip = true
            mc.thePlayer.fallDistance = 0f
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.motionX = 0.0
            mc.thePlayer.motionZ = 0.0
            if (mc.gameSettings.keyBindJump.isKeyDown) mc.thePlayer.motionY += 1.0
            if (mc.gameSettings.keyBindSneak.isKeyDown) mc.thePlayer.motionY -= 1.0
            MovementUtils.strafe(2f)

        }
    }

    @EventTarget
    fun onPacket(event:PacketEvent) {
        if (mc.thePlayer == null || mc.theWorld == null) { this.toggle(); return }

        val packet = event.packet
        if (packet is C03PacketPlayer) {
            if (stage == 0) {
                event.cancelEvent()
            }
            else {
                ClientUtils.displayChatMessage("Trying to teleport to X: ${tpPos.x} Y: ${tpPos.y} Z: ${tpPos.z}...")
                packet.x = tpPos.x.toDouble()
                packet.y = tpPos.y.toDouble()
                packet.z = tpPos.z.toDouble()
            }
        }
    }

    fun reset() {
        timer.reset()
        stage = 0
        tpPos = mc.thePlayer.position
    }

}